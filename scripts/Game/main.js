import {
  Camera,
  Color,
  Component,
  Keyboard,
  Mouse,
  RenderComponent,
  RigidbodyComponent,
  Runtime_default,
  ShapeRendererComponent,
  TileMap,
  TileRendererComponent,
  Vector2,
  __name,
  lerp,
  pointInPolygon
} from "../chunk-ZPRAT366.js";

// src/Game/Components/CameraFollowComponent.ts
var CameraFollowComponent = class extends Component {
  defaults = {
    followSpeed: 0.8,
    threshold: 100
  };
  update({ followSpeed, threshold }, entity) {
    const speed = Camera.position.distance(entity.transform.position) / (threshold / Camera.zoom) * followSpeed;
    Camera.position = Camera.position.lerp(entity.transform.position, speed);
    if (Runtime_default.debug) {
      Runtime_default.canvas.vector(Camera.cameraToWorldSpace(new Vector2(50, 50)), 0, Vector2.up.multiply(40).divide(Camera.zoom), Color.red);
    }
  }
};
__name(CameraFollowComponent, "CameraFollowComponent");

// src/Game/Components/FollowPlayerComponent.ts
var FollowPlayerComponent = class extends Component {
  dependencies = [RigidbodyComponent];
  defaults = {
    speed: 1,
    distance: 16
  };
  update(attributes, entity) {
    const player = Runtime_default.getEntity("player");
    const rigidbody = entity.getComponent(RigidbodyComponent);
    if (!player)
      throw new Error("No player entity found.");
    const distance = entity.transform.position.distance(player.transform.position);
    if (distance > attributes.distance)
      rigidbody.velocity = entity.transform.position.minus(player.transform.position).normalize().invert().multiply(attributes.speed).limit(attributes.distance);
  }
};
__name(FollowPlayerComponent, "FollowPlayerComponent");

// src/Game/Components/KeyboardControllerComponent.ts
var KeyboardControllerComponent = class extends Component {
  dependencies = [RigidbodyComponent];
  defaults = {
    speed: 1,
    sprintSpeed: 5,
    velocity: new Vector2()
  };
  update(attributes, entity) {
    const rigidbody = entity.getComponent(RigidbodyComponent);
    let { speed, sprintSpeed } = attributes;
    if (Keyboard.isDown("shift"))
      speed = sprintSpeed;
    let direction = Vector2.zero;
    if (Keyboard.isDown("s")) {
      direction = direction.add(Vector2.down);
    }
    if (Keyboard.isDown("w")) {
      direction = direction.add(Vector2.up);
    }
    if (Keyboard.isDown("a")) {
      direction = direction.add(Vector2.left);
    }
    if (Keyboard.isDown("d")) {
      direction = direction.add(Vector2.right);
    }
    direction = direction.rotate(-Camera.rotation);
    rigidbody.velocity = rigidbody.velocity.add(direction);
  }
};
__name(KeyboardControllerComponent, "KeyboardControllerComponent");

// src/Game/Components/MouseControllerComponent.ts
var MouseControllerComponent = class extends Component {
  dependencies = [RigidbodyComponent];
  defaults = {
    speed: 1
  };
  update(attributes, entity) {
    const { speed } = attributes;
    const rigidbody = entity.getComponent(RigidbodyComponent);
    attributes.speed = Mouse.right ? 7.5 : 2.5;
    if (Mouse.middle)
      attributes.speed = Mouse.position.minus(entity.transform.position).length;
    rigidbody.velocity = Mouse.position.minus(entity.transform.position).normalize().multiply(speed);
  }
};
__name(MouseControllerComponent, "MouseControllerComponent");

// src/Game/Components/RotateComponent.ts
var RotateComponent = class extends RenderComponent {
  defaults = {
    rotationSpeed: 1
  };
  render(attributes, entity) {
    entity.transform.rotation += attributes.rotationSpeed;
  }
};
__name(RotateComponent, "RotateComponent");

// src/Game/Components/ZoomComponent.ts
var ZoomComponent = class extends Component {
  defaults = {
    cameraRotation: 0,
    zoom: 1,
    zoomSpeed: 0.05
  };
  update(attributes) {
    if (Keyboard.isPressed("arrowright"))
      attributes.cameraRotation += 45;
    if (Keyboard.isPressed("arrowleft"))
      attributes.cameraRotation -= 45;
    attributes.zoom = lerp(attributes.zoom, Math.max(1, Math.min(Mouse.wheel + 1, 16)), 0.8);
    Camera.rotation = lerp(Camera.rotation, attributes.cameraRotation, 0.02);
    Camera.zoom = lerp(Camera.zoom, attributes.zoom, attributes.zoomSpeed);
  }
};
__name(ZoomComponent, "ZoomComponent");

// src/Game/Components/MouseComponent.ts
var MouseComponent = class extends Component {
  dependencies = [ShapeRendererComponent];
  start(attributes, entity) {
  }
  update(attributes, entity) {
    const shapes2 = entity.getComponent(ShapeRendererComponent);
    const mousePosition = Camera.cameraToWorldSpace(Mouse.position).minus(entity.transform.position);
    shapes2.shapes.forEach((x) => x.color = pointInPolygon(mousePosition, entity.bounds.complex) ? Color.red : Color.blue);
  }
};
__name(MouseComponent, "MouseComponent");

// src/Game/main.ts
Runtime_default.registerComponent(MouseControllerComponent, KeyboardControllerComponent, FollowPlayerComponent, ZoomComponent, RotateComponent, CameraFollowComponent, MouseComponent);
var shapes = [
  {
    offset: Vector2.zero,
    rotation: 225,
    color: Color.red,
    type: "circle",
    size: 32
  }
];
async function start() {
  Runtime_default.canvas.background = Color.black;
  const tileMap = await TileMap.load("assets/tilemap.png", { tileWidth: 16, tileHeight: 16 });
  const player = Runtime_default.createEntity("player");
  player.addComponent(TileRendererComponent, {
    tileMap,
    tile: [13, 14, 15]
  });
  player.addComponent([CameraFollowComponent, KeyboardControllerComponent, ZoomComponent, RotateComponent]);
  const enemy = Runtime_default.createEntity("enemy");
  enemy.transform.position = Vector2.random.multiply(100);
  enemy.addComponent(ShapeRendererComponent, {
    shapes
  });
  for (let i = 0; i < 1200; i++) {
    const clone = enemy.clone();
    clone.transform.position = Vector2.random.multiply(1600);
    clone.getComponent(ShapeRendererComponent).shapes[0].color = Color.random();
    Runtime_default.registerEntity(clone);
  }
}
__name(start, "start");
start();
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vc3JjL0dhbWUvQ29tcG9uZW50cy9DYW1lcmFGb2xsb3dDb21wb25lbnQudHMiLCAiLi4vLi4vLi4vc3JjL0dhbWUvQ29tcG9uZW50cy9Gb2xsb3dQbGF5ZXJDb21wb25lbnQudHMiLCAiLi4vLi4vLi4vc3JjL0dhbWUvQ29tcG9uZW50cy9LZXlib2FyZENvbnRyb2xsZXJDb21wb25lbnQudHMiLCAiLi4vLi4vLi4vc3JjL0dhbWUvQ29tcG9uZW50cy9Nb3VzZUNvbnRyb2xsZXJDb21wb25lbnQudHMiLCAiLi4vLi4vLi4vc3JjL0dhbWUvQ29tcG9uZW50cy9Sb3RhdGVDb21wb25lbnQudHMiLCAiLi4vLi4vLi4vc3JjL0dhbWUvQ29tcG9uZW50cy9ab29tQ29tcG9uZW50LnRzIiwgIi4uLy4uLy4uL3NyYy9HYW1lL0NvbXBvbmVudHMvTW91c2VDb21wb25lbnQudHMiLCAiLi4vLi4vLi4vc3JjL0dhbWUvbWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IENhbWVyYSBmcm9tICdAL1JlbmRlcmVyL0NhbWVyYSc7XG5pbXBvcnQgR2FtZSwgeyBDb2xvciwgQ29tcG9uZW50LCBFbnRpdHksIFZlY3RvcjIgfSBmcm9tICdFbmdpbmUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYW1lcmFGb2xsb3dDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIG92ZXJyaWRlIGRlZmF1bHRzID0ge1xuICAgICAgICBmb2xsb3dTcGVlZDogMC44LFxuICAgICAgICB0aHJlc2hvbGQ6IDEwMFxuICAgIH07XG5cblxuICAgIG92ZXJyaWRlIHVwZGF0ZSh7IGZvbGxvd1NwZWVkLCB0aHJlc2hvbGQgfTogdGhpc1snZGVmYXVsdHMnXSwgZW50aXR5OiBFbnRpdHkpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgc3BlZWQgPSBDYW1lcmEucG9zaXRpb24uZGlzdGFuY2UoZW50aXR5LnRyYW5zZm9ybS5wb3NpdGlvbikgLyAodGhyZXNob2xkIC8gQ2FtZXJhLnpvb20pICogZm9sbG93U3BlZWQ7XG5cbiAgICAgICAgQ2FtZXJhLnBvc2l0aW9uID0gQ2FtZXJhLnBvc2l0aW9uLmxlcnAoZW50aXR5LnRyYW5zZm9ybS5wb3NpdGlvbiwgc3BlZWQpO1xuXG4gICAgICAgIGlmIChHYW1lLmRlYnVnKSB7XG4gICAgICAgICAgICBHYW1lLmNhbnZhcy52ZWN0b3IoXG4gICAgICAgICAgICAgICAgQ2FtZXJhLmNhbWVyYVRvV29ybGRTcGFjZShcbiAgICAgICAgICAgICAgICAgICAgbmV3IFZlY3RvcjIoNTAsIDUwKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICBWZWN0b3IyLnVwLm11bHRpcGx5KDQwKS5kaXZpZGUoQ2FtZXJhLnpvb20pLFxuICAgICAgICAgICAgICAgIENvbG9yLnJlZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsICJpbXBvcnQgUmlnaWRib2R5Q29tcG9uZW50IGZyb20gJ0AvQ29tcG9uZW50cy9SaWdpZGJvZHlDb21wb25lbnQnO1xuaW1wb3J0IEdhbWUsIHsgQ29tcG9uZW50LCBFbnRpdHksIFZlY3RvcjIgfSBmcm9tICdFbmdpbmUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb2xsb3dQbGF5ZXJDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIG92ZXJyaWRlIHJlYWRvbmx5IGRlcGVuZGVuY2llcyA9IFtSaWdpZGJvZHlDb21wb25lbnRdO1xuXG4gICAgb3ZlcnJpZGUgZGVmYXVsdHMgPSB7XG4gICAgICAgIHNwZWVkOiAxLFxuICAgICAgICBkaXN0YW5jZTogMTZcbiAgICB9O1xuXG4gICAgb3ZlcnJpZGUgdXBkYXRlKGF0dHJpYnV0ZXM6IHRoaXNbJ2RlZmF1bHRzJ10sIGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHBsYXllciA9IEdhbWUuZ2V0RW50aXR5KFwicGxheWVyXCIpO1xuICAgICAgICBjb25zdCByaWdpZGJvZHkgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFJpZ2lkYm9keUNvbXBvbmVudCk7XG5cbiAgICAgICAgaWYgKCFwbGF5ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwbGF5ZXIgZW50aXR5IGZvdW5kLlwiKTtcblxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGVudGl0eS50cmFuc2Zvcm0ucG9zaXRpb24uZGlzdGFuY2UocGxheWVyLnRyYW5zZm9ybS5wb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGRpc3RhbmNlID4gYXR0cmlidXRlcy5kaXN0YW5jZSlcbiAgICAgICAgICAgIHJpZ2lkYm9keS52ZWxvY2l0eSA9IGVudGl0eS50cmFuc2Zvcm0ucG9zaXRpb24ubWludXMocGxheWVyLnRyYW5zZm9ybS5wb3NpdGlvbikubm9ybWFsaXplKCkuaW52ZXJ0KCkubXVsdGlwbHkoYXR0cmlidXRlcy5zcGVlZCkubGltaXQoYXR0cmlidXRlcy5kaXN0YW5jZSk7XG4gICAgfVxufSIsICJpbXBvcnQgeyBDYW1lcmEgfSBmcm9tICdAL1JlbmRlcmVyJztcbmltcG9ydCBSaWdpZGJvZHlDb21wb25lbnQgZnJvbSAnQC9Db21wb25lbnRzL1JpZ2lkYm9keUNvbXBvbmVudCc7XG5pbXBvcnQgR2FtZSwgeyBDb21wb25lbnQsIEVudGl0eSwgS2V5Ym9hcmQsIFZlY3RvcjIgfSBmcm9tICdFbmdpbmUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLZXlib2FyZENvbnRyb2xsZXJDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gICAgb3ZlcnJpZGUgcmVhZG9ubHkgZGVwZW5kZW5jaWVzID0gW1JpZ2lkYm9keUNvbXBvbmVudF07XG5cbiAgICBvdmVycmlkZSBkZWZhdWx0cyA9IHtcbiAgICAgICAgc3BlZWQ6IDEsXG4gICAgICAgIHNwcmludFNwZWVkOiA1LFxuICAgICAgICB2ZWxvY2l0eTogbmV3IFZlY3RvcjIoKVxuICAgIH07XG5cbiAgICBvdmVycmlkZSB1cGRhdGUoYXR0cmlidXRlczogdGhpc1snZGVmYXVsdHMnXSwgZW50aXR5OiBFbnRpdHkpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcmlnaWRib2R5ID0gZW50aXR5LmdldENvbXBvbmVudChSaWdpZGJvZHlDb21wb25lbnQpO1xuICAgICAgICBsZXQgeyBzcGVlZCwgc3ByaW50U3BlZWQgfSA9IGF0dHJpYnV0ZXM7XG5cbiAgICAgICAgaWYgKEtleWJvYXJkLmlzRG93bihcInNoaWZ0XCIpKVxuICAgICAgICAgICAgc3BlZWQgPSBzcHJpbnRTcGVlZDtcblxuICAgICAgICBsZXQgZGlyZWN0aW9uID0gVmVjdG9yMi56ZXJvO1xuICAgICAgICBpZiAoS2V5Ym9hcmQuaXNEb3duKFwic1wiKSkge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gZGlyZWN0aW9uLmFkZChWZWN0b3IyLmRvd24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEtleWJvYXJkLmlzRG93bihcIndcIikpIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IGRpcmVjdGlvbi5hZGQoVmVjdG9yMi51cCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoS2V5Ym9hcmQuaXNEb3duKFwiYVwiKSkge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gZGlyZWN0aW9uLmFkZChWZWN0b3IyLmxlZnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEtleWJvYXJkLmlzRG93bihcImRcIikpIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IGRpcmVjdGlvbi5hZGQoVmVjdG9yMi5yaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBkaXJlY3Rpb24gPSBkaXJlY3Rpb24ucm90YXRlKC1DYW1lcmEucm90YXRpb24pO1xuXG4gICAgICAgIHJpZ2lkYm9keS52ZWxvY2l0eSA9IHJpZ2lkYm9keS52ZWxvY2l0eS5hZGQoZGlyZWN0aW9uKTtcbiAgICB9XG5cbn0iLCAiaW1wb3J0IFJpZ2lkYm9keUNvbXBvbmVudCBmcm9tICdAL0NvbXBvbmVudHMvUmlnaWRib2R5Q29tcG9uZW50JztcbmltcG9ydCB7IENvbXBvbmVudCwgRW50aXR5LCBNb3VzZSwgVmVjdG9yMiB9IGZyb20gJ0VuZ2luZSc7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW91c2VDb250cm9sbGVyQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIG92ZXJyaWRlIHJlYWRvbmx5IGRlcGVuZGVuY2llcyA9IFtSaWdpZGJvZHlDb21wb25lbnRdO1xuXG4gICAgb3ZlcnJpZGUgZGVmYXVsdHMgPSB7XG4gICAgICAgIHNwZWVkOiAxLFxuICAgIH07XG5cbiAgICBvdmVycmlkZSB1cGRhdGUoYXR0cmlidXRlczogdGhpc1snZGVmYXVsdHMnXSwgZW50aXR5OiBFbnRpdHkpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgeyBzcGVlZCB9ID0gYXR0cmlidXRlcztcbiAgICAgICAgY29uc3QgcmlnaWRib2R5ID0gZW50aXR5LmdldENvbXBvbmVudChSaWdpZGJvZHlDb21wb25lbnQpXG5cbiAgICAgICAgYXR0cmlidXRlcy5zcGVlZCA9IE1vdXNlLnJpZ2h0ID8gNy41IDogMi41O1xuICAgICAgICBpZiAoTW91c2UubWlkZGxlKVxuICAgICAgICAgICAgYXR0cmlidXRlcy5zcGVlZCA9IE1vdXNlLnBvc2l0aW9uLm1pbnVzKGVudGl0eS50cmFuc2Zvcm0ucG9zaXRpb24pLmxlbmd0aDtcblxuICAgICAgICByaWdpZGJvZHkudmVsb2NpdHkgPSBNb3VzZS5wb3NpdGlvbi5taW51cyhlbnRpdHkudHJhbnNmb3JtLnBvc2l0aW9uKS5ub3JtYWxpemUoKS5tdWx0aXBseShzcGVlZCk7XG4gICAgfVxuXG59IiwgImltcG9ydCBSZW5kZXJDb21wb25lbnQgZnJvbSAnQC9Db21wb25lbnRzL1JlbmRlckNvbXBvbmVudCc7XG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICdFbmdpbmUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3RhdGVDb21wb25lbnQgZXh0ZW5kcyBSZW5kZXJDb21wb25lbnQge1xuXG4gICAgb3ZlcnJpZGUgZGVmYXVsdHMgPSB7XG4gICAgICAgIHJvdGF0aW9uU3BlZWQ6IDFcbiAgICB9O1xuXG4gICAgb3ZlcnJpZGUgcmVuZGVyKGF0dHJpYnV0ZXM6IHRoaXNbXCJkZWZhdWx0c1wiXSwgZW50aXR5OiBFbnRpdHkpIHtcbiAgICAgICAgZW50aXR5LnRyYW5zZm9ybS5yb3RhdGlvbiArPSBhdHRyaWJ1dGVzLnJvdGF0aW9uU3BlZWQ7XG4gICAgfVxuXG59IiwgImltcG9ydCB7IENhbWVyYSB9IGZyb20gJ0AvUmVuZGVyZXInO1xuaW1wb3J0IHsgbGVycCB9IGZyb20gJ0AvSGVscGVycyc7XG5pbXBvcnQgR2FtZSwgeyBDb2xvciwgQ29tcG9uZW50LCBLZXlib2FyZCwgTW91c2UsIFZlY3RvcjIgfSBmcm9tICdFbmdpbmUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBab29tQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIG92ZXJyaWRlIGRlZmF1bHRzID0ge1xuICAgICAgICBjYW1lcmFSb3RhdGlvbjogMCxcbiAgICAgICAgem9vbTogMSxcbiAgICAgICAgem9vbVNwZWVkOiAwLjA1XG4gICAgfTtcblxuICAgIG92ZXJyaWRlIHVwZGF0ZShhdHRyaWJ1dGVzOiB0aGlzW1wiZGVmYXVsdHNcIl0pIHtcbiAgICAgICAgaWYgKEtleWJvYXJkLmlzUHJlc3NlZChcImFycm93cmlnaHRcIikpXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmNhbWVyYVJvdGF0aW9uICs9IDQ1O1xuXG4gICAgICAgIGlmIChLZXlib2FyZC5pc1ByZXNzZWQoXCJhcnJvd2xlZnRcIikpXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmNhbWVyYVJvdGF0aW9uIC09IDQ1O1xuICAgICAgICBhdHRyaWJ1dGVzLnpvb20gPSBsZXJwKGF0dHJpYnV0ZXMuem9vbSwgTWF0aC5tYXgoMSwgTWF0aC5taW4oTW91c2Uud2hlZWwgKyAxLCAxNikpLCAwLjgpO1xuXG4gICAgICAgIENhbWVyYS5yb3RhdGlvbiA9IGxlcnAoQ2FtZXJhLnJvdGF0aW9uLCBhdHRyaWJ1dGVzLmNhbWVyYVJvdGF0aW9uLCAwLjAyKTtcbiAgICAgICAgQ2FtZXJhLnpvb20gPSBsZXJwKENhbWVyYS56b29tLCBhdHRyaWJ1dGVzLnpvb20sIGF0dHJpYnV0ZXMuem9vbVNwZWVkKTtcbiAgICB9XG5cbn0iLCAiaW1wb3J0IFNoYXBlUmVuZGVyZXJDb21wb25lbnQgZnJvbSAnQC9Db21wb25lbnRzL1NoYXBlUmVuZGVyZXJDb21wb25lbnQnO1xuaW1wb3J0IHsgcG9pbnRJblBvbHlnb24gfSBmcm9tICdAL0hlbHBlcnMnO1xuaW1wb3J0IHsgQ2FtZXJhIH0gZnJvbSAnQC9SZW5kZXJlcic7XG5pbXBvcnQgR2FtZSwgeyBDb2xvciwgQ29tcG9uZW50LCBFbnRpdHksIE1vdXNlIH0gZnJvbSAnRW5naW5lJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW91c2VDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIG92ZXJyaWRlIGRlcGVuZGVuY2llcyA9IFtTaGFwZVJlbmRlcmVyQ29tcG9uZW50XTtcblxuICAgIG92ZXJyaWRlIHN0YXJ0KGF0dHJpYnV0ZXM6IHRoaXNbJ2RlZmF1bHRzJ10sIGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgfVxuXG4gICAgb3ZlcnJpZGUgdXBkYXRlKGF0dHJpYnV0ZXM6IHRoaXNbJ2RlZmF1bHRzJ10sIGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHNoYXBlcyA9IGVudGl0eS5nZXRDb21wb25lbnQoU2hhcGVSZW5kZXJlckNvbXBvbmVudCk7XG5cbiAgICAgICAgY29uc3QgbW91c2VQb3NpdGlvbiA9IENhbWVyYS5jYW1lcmFUb1dvcmxkU3BhY2UoTW91c2UucG9zaXRpb24pLm1pbnVzKGVudGl0eS50cmFuc2Zvcm0ucG9zaXRpb24pO1xuXG4gICAgICAgIHNoYXBlcy5zaGFwZXMuZm9yRWFjaCh4ID0+IHguY29sb3IgPSBwb2ludEluUG9seWdvbihtb3VzZVBvc2l0aW9uLCBlbnRpdHkuYm91bmRzLmNvbXBsZXgpID8gQ29sb3IucmVkIDogQ29sb3IuYmx1ZSk7XG4gICAgfVxufSIsICJpbXBvcnQgeyBDYW1lcmEgfSBmcm9tICdAL1JlbmRlcmVyJztcbmltcG9ydCBTaGFwZVJlbmRlcmVyQ29tcG9uZW50IGZyb20gJ0AvQ29tcG9uZW50cy9TaGFwZVJlbmRlcmVyQ29tcG9uZW50JztcbmltcG9ydCBUaWxlUmVuZGVyZXJDb21wb25lbnQgZnJvbSAnQC9Db21wb25lbnRzL1RpbGVSZW5kZXJlckNvbXBvbmVudCc7XG5pbXBvcnQgdHlwZSB7IFNoYXBlIH0gZnJvbSAnQC9SZW5kZXJlcic7XG5pbXBvcnQgR2FtZSwgeyBDb2xvciwgRW50aXR5LCBNb3VzZSwgVGlsZW1hcCwgVmVjdG9yMiB9IGZyb20gJ0VuZ2luZSc7XG5pbXBvcnQgQ2FtZXJhRm9sbG93Q29tcG9uZW50IGZyb20gJy4vQ29tcG9uZW50cy9DYW1lcmFGb2xsb3dDb21wb25lbnQnO1xuaW1wb3J0IEZvbGxvd1BsYXllckNvbXBvbmVudCBmcm9tICcuL0NvbXBvbmVudHMvRm9sbG93UGxheWVyQ29tcG9uZW50JztcbmltcG9ydCBLZXlib2FyZENvbnRyb2xsZXJDb21wb25lbnQgZnJvbSAnLi9Db21wb25lbnRzL0tleWJvYXJkQ29udHJvbGxlckNvbXBvbmVudCc7XG5pbXBvcnQgTW91c2VDb250cm9sbGVyQ29tcG9uZW50IGZyb20gJy4vQ29tcG9uZW50cy9Nb3VzZUNvbnRyb2xsZXJDb21wb25lbnQnO1xuaW1wb3J0IFJvdGF0ZUNvbXBvbmVudCBmcm9tICcuL0NvbXBvbmVudHMvUm90YXRlQ29tcG9uZW50JztcbmltcG9ydCBab29tQ29tcG9uZW50IGZyb20gJy4vQ29tcG9uZW50cy9ab29tQ29tcG9uZW50JztcbmltcG9ydCBDb252ZXggZnJvbSAnQC9SZW5kZXJlci9Db252ZXgnO1xuaW1wb3J0IE1vdXNlQ29tcG9uZW50IGZyb20gJy4vQ29tcG9uZW50cy9Nb3VzZUNvbXBvbmVudCc7XG5cbkdhbWUucmVnaXN0ZXJDb21wb25lbnQoXG4gICAgTW91c2VDb250cm9sbGVyQ29tcG9uZW50LFxuICAgIEtleWJvYXJkQ29udHJvbGxlckNvbXBvbmVudCxcbiAgICBGb2xsb3dQbGF5ZXJDb21wb25lbnQsXG4gICAgWm9vbUNvbXBvbmVudCxcbiAgICBSb3RhdGVDb21wb25lbnQsXG4gICAgQ2FtZXJhRm9sbG93Q29tcG9uZW50LFxuICAgIE1vdXNlQ29tcG9uZW50XG4pO1xuY29uc3Qgc2hhcGVzOiBTaGFwZVtdID0gW1xuICAgIHtcbiAgICAgICAgb2Zmc2V0OiBWZWN0b3IyLnplcm8sXG4gICAgICAgIHJvdGF0aW9uOiAyMjUsXG4gICAgICAgIGNvbG9yOiBDb2xvci5yZWQsXG4gICAgICAgIHR5cGU6IFwiY2lyY2xlXCIsXG4gICAgICAgIHNpemU6IDMyXG4gICAgfVxuXTtcblxuYXN5bmMgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgR2FtZS5jYW52YXMuYmFja2dyb3VuZCA9IENvbG9yLmJsYWNrO1xuXG4gICAgY29uc3QgdGlsZU1hcCA9IGF3YWl0IFRpbGVtYXAubG9hZChcImFzc2V0cy90aWxlbWFwLnBuZ1wiLCB7IHRpbGVXaWR0aDogMTYsIHRpbGVIZWlnaHQ6IDE2IH0pO1xuXG4gICAgY29uc3QgcGxheWVyID0gR2FtZS5jcmVhdGVFbnRpdHkoXCJwbGF5ZXJcIik7XG5cbiAgICBwbGF5ZXIuYWRkQ29tcG9uZW50KFRpbGVSZW5kZXJlckNvbXBvbmVudCwge1xuICAgICAgICB0aWxlTWFwLFxuICAgICAgICB0aWxlOiBbMTMsIDE0LCAxNV1cbiAgICB9KTtcbiAgICBwbGF5ZXIuYWRkQ29tcG9uZW50KFtDYW1lcmFGb2xsb3dDb21wb25lbnQsIEtleWJvYXJkQ29udHJvbGxlckNvbXBvbmVudCwgWm9vbUNvbXBvbmVudCwgUm90YXRlQ29tcG9uZW50XSk7XG5cblxuICAgIGNvbnN0IGVuZW15ID0gR2FtZS5jcmVhdGVFbnRpdHkoXCJlbmVteVwiKTtcbiAgICBlbmVteS50cmFuc2Zvcm0ucG9zaXRpb24gPSBWZWN0b3IyLnJhbmRvbS5tdWx0aXBseSgxMDApO1xuICAgIGVuZW15LmFkZENvbXBvbmVudChTaGFwZVJlbmRlcmVyQ29tcG9uZW50LCB7XG4gICAgICAgIHNoYXBlc1xuICAgIH0pO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjAwOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBlbmVteS5jbG9uZSgpO1xuICAgICAgICBjbG9uZS50cmFuc2Zvcm0ucG9zaXRpb24gPSBWZWN0b3IyLnJhbmRvbS5tdWx0aXBseSgxNjAwKTtcbiAgICAgICAgY2xvbmUuZ2V0Q29tcG9uZW50KFNoYXBlUmVuZGVyZXJDb21wb25lbnQpLnNoYXBlc1swXS5jb2xvciA9IENvbG9yLnJhbmRvbSgpO1xuXG4gICAgICAgIEdhbWUucmVnaXN0ZXJFbnRpdHkoY2xvbmUpO1xuICAgIH1cbn1cblxuc3RhcnQoKTtcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQSwwQ0FBbUQsVUFBVTtBQUFBLEVBQ2hELFdBQVc7QUFBQSxJQUNoQixhQUFhO0FBQUEsSUFDYixXQUFXO0FBQUE7QUFBQSxFQUlOLE9BQU8sRUFBRSxhQUFhLGFBQStCLFFBQXNCO0FBQ2hGLFVBQU0sUUFBUSxPQUFPLFNBQVMsU0FBUyxPQUFPLFVBQVUsWUFBYSxhQUFZLE9BQU8sUUFBUTtBQUVoRyxXQUFPLFdBQVcsT0FBTyxTQUFTLEtBQUssT0FBTyxVQUFVLFVBQVU7QUFFbEUsUUFBSSxnQkFBSyxPQUFPO0FBQ1osc0JBQUssT0FBTyxPQUNSLE9BQU8sbUJBQ0gsSUFBSSxRQUFRLElBQUksTUFFcEIsR0FDQSxRQUFRLEdBQUcsU0FBUyxJQUFJLE9BQU8sT0FBTyxPQUN0QyxNQUFNO0FBQUE7QUFBQTtBQUFBO0FBbkJ0Qjs7O0FDQUEsMENBQW1ELFVBQVU7QUFBQSxFQUN2QyxlQUFlLENBQUM7QUFBQSxFQUV6QixXQUFXO0FBQUEsSUFDaEIs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
